{-# LANGUAGE NoMonomorphismRestriction, FlexibleContexts #-}
module PreProcessor.Preprocessor where

-- Map from type names to valid Constructors for the type

import Models.Program
import Types.Utils hiding (find)
import Control.Monad (foldM)
import Control.Monad.Trans
import Control.Monad.Trans.Either
import Control.Monad.State
import qualified Data.Map.Strict as M
import qualified Data.Set as S
import Data.List (find)
import Data.Maybe (isJust)
import GHC.Exts (groupWith)
import Text.Megaparsec.Pos

type PP a = State Int a

preprocess :: [Top] -> PP (ClassEnv, [Assump], Expr)
preprocess ts = do
    let (bnds, rdt, adt, bvs, imps) = splitTops ts
    (fbs, recCE) <- processRecs rdt
    let (expl,impl) = splitBinds (bnds ++ fbs)
    (expl', overCE) <- overload expl
    (stbs, bhCE) <- makeCE bvs imps

    ce <- mergeCEs [bhCE, overCE, recCE] 

    let aAssumps = map (uncurry (:>:)) (concatMap dCstrs adt)
        rAssumps = map (uncurry (:>:)) (concatMap dCstrs rdt)
        assumps = rAssumps ++ aAssumps

    let impl' = map Impl impl
    let binds = impl' ++ expl' ++ stbs

    let aNames = concatMap dNames adt
        rNames = concatMap dNames rdt
        bNames = behaviorNames ce
        nNames = map bindingName binds
        names = aNames ++ rNames ++ bNames ++ nNames
    unless (uniq names) (fail "Duplicate name found")
    fullAp (map dTCons adt ++ map dTCons rdt) binds
 
    main <- genMain binds
    return (ce, assumps, main)

mergeCEs = undefined
uniq = undefined

processRecs :: [Rec] -> PP ([Binding], ClassEnv)
processRecs rs = do
    (is, _) <- foldM promote ([],[]) rs
    let subclasses = map (dTCons . snd) is
        regs = filter (\a -> dTCons a `elem` subclasses) rs
        rfBind = concatMap fieldBinds regs
        classes = groupWith (tname . dTCons . fst) is
        classList = M.fromList $ map makeSuperClass classes
        ce = M.fromList 
    (bs, ce) <- unzip <$> mapM makeSuperType classes
    {-return(rfBind ++ bs, ce)-}
    fail ""

tname (Tycon n _) = n
    
someFunc :: [(Rec,Rec)] -> PP ([Binding],(Id,Class))
someFunc rs@((sup,_):_) = do
    let imps = sup : map snd rs
        cb@(_,(_,_,bs)) = makeSuperClass sup imps
        (overs,unders) = map (bindSup bs) imps

    let groups = groupWith (\(n,_,_) -> n) over
        overBinds = map binds2Over groups
        stubs = map fst overBinds

makeSuperClass :: Rec -> [Rec] -> (Id,Class)
makeSuperClass s impl =
    let stubs = map fst (rfields s)
        name = '*' : tname (dTCons s)
        supers = map (('*':) . consName) (sups s)
        impls = s : map snd rs
        ts = map qualed impls
        insts = map (\(q:=>t) -> q :=> IsIn name [t]) ts
    in (name, (supers, insts, stubs))

qualed (Rec q t _ _) = q :=> t
-- Return the list of overloaded field bindings and the
-- list of type-specific bindings
bindSup :: [Id] -> Rec -> PP ([(Id,Scheme, Expr)], [(Id,Schme,Expr)])
bindSup stubs r = do 
    let fbs = fieldBinds r
        (over,under) = break inStubs fbs
    unless (length stubs == length over) 
           (fail "Must include all fields of super type")
    return (over, under)
    where inStubs (b,_,_) = b `elem` stubs


binds2Over :: [(Id,Scheme, Expr)] -> (Id,Expr)
binds2Over bs@((n,_,_):_) = 
    let ps = map (\(_,s,e) -> (s,e)) bs
    in (n,Over ps)

fieldBinds (Rec q t _ fs) = zipWith f fs [0..]
    where f (n, ft) i = let sch = quantQual q ([ft] `mkFun` t)
                          in (n, sch, Var ("#ACC" ++ show i))

promote :: ([(Rec, Rec)], [Rec]) -> Rec -> PP ([(Rec, Rec)], [Rec])
promote (is,rs) r@(Rec q t s ts) = do
    impls <- mapM (subclass r rs) s 
    return (impls ++ is, r:rs)

subclass :: Rec -> [Rec] -> Type -> PP (Rec,Rec)
subclass r rs s = case supDefined s rs of
    (Just sup) -> return (sup,r)
    Nothing  -> fail "Super class not defined"

supDefined :: Type -> [Rec] -> Maybe Rec
supDefined s = find (\x -> getCons s == dTCons x)


              {-ss <- (supDefined s rs) (fail "Super class not defined")-}



overload :: [(Id, Scheme, Expr)] -> PP ([Binding], ClassEnv)
overload bs = do
    let groups = groupWith (\(i,_,_) -> i) bs
        (under,over) = break ((1 ==) . length) groups
    return under
    (bs, ces) <- unzip <$> mapM overBehavior over
    let bnds = map Expl (concat under ++ bs)
    return (bnds, M.unions ces)


overBehavior bs@((i,_, _):_) = do
    pairs <- mapM check bs
    let cname = "_over_" ++ i
        ps = [IsIn cname [TGen 0]]
        sch = Forall [Star] (ps :=> TGen 0)
        {-bind = Expl i sch (Over pairs)-}
    insts <- mapM (buildClass cname) pairs
    return ((i, sch, Over pairs), M.fromList [(cname, ([], insts))])
    where check (_, sc, ex) = if null (tv sc)
                then return (sc,ex)
                else fail $ "Incomplete type signature for" ++ i
          buildClass cls (sc, _) = do
              (ps :=> t) <- freshInst sc
              return $ ps :=>  IsIn cls [t]

splitWith fn ss = let s = map fn ss
                 in (concatMap fst s, concatMap snd s)

splitBinds = splitWith splitBind 
    where  splitBind (Expl e) = ([e],[]) 

           splitBind (Impl i) = ([],[i]) 

freshInst :: Scheme -> PP (Qual Type)
freshInst (Forall ks qt) = do ts <- mapM newTVar ks
                              return (inst ts qt)

consName (TAp t _) = consName t
consName (TCons (Tycon n _)) = n

bindingName (Expl (i,_,_)) = i
bindingName (Impl (i,_)) = i

behaviorNames = M.keys

makeCE :: [Behavior] -> [Implementation] -> PP ([Binding], ClassEnv)
makeCE = undefined

fullAp :: [Tycon] -> [Binding] -> PP ()
fullAp _ _ = return ()

genMain :: [Binding] -> PP Expr
genMain bs = do
    let (m, bs) = break (("main" ==) . bindingName) bs
    unless (length m == 1) (fail "Could not find main")
    return $ Let (splitBinds bs) (exprOf $ head m)
    where exprOf (Impl (_,e)) = e
          exprOf (Expl (_,_,e)) = e
    

newTVar k = do i <- get
               let v = "&var" ++ show i
               put (i + 1)
               return $ TVar $ Tyvar v k

splitTops :: [Top] -> ([Binding], [Rec], [Adt], [Behavior], [Implementation])
splitTops = foldl split ([],[],[],[],[])
    where split (bs, rs, as, cs, is) (Bind b) = (b:bs, rs, as, cs, is)
          split (bs, rs, as, cs, is) (RDT r) = (bs, r:rs, as, cs, is)
          split (bs, rs, as, cs, is) (ADT a) = (bs, rs, a:as, cs, is)
          split (bs, rs, as, cs, is) (Bvr b) = (bs, rs, as, b:cs, is)
          split (bs, rs, as, cs, is) (Imp i) = (bs, rs, as, cs, i:is)
